<!DOCTYPE html>
<html>
<head><title>STL Previews</title></head>
<style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      overflow: hidden;
    }

  #container {
    display: flex;
    height: 100vh;
    width: 100vw;
  }

  #splitter {
    width: 5px;
    cursor: col-resize;
    background: #ddd;
    z-index: 10;
    height: 100vh;
    pointer-events: auto;
  }

  #viewer {
    flex: 1;
    overflow: auto;
    position: relative;
  }

  #tree {
    width: 300px;
    min-width: 150px;
    max-width: 600px;  
    font-family: sans-serif;
    overflow-y: auto;
    height: 100vh;
    background-color: #f9f9f9;
    border-right: 1px solid #ccc;
  }

  #tree div {
    user-select: none;
  }

  #tree .folder {
    font-weight: bold;
    cursor: pointer;
  }

  #tree .file {
    cursor: pointer;
  }

  #tree .file:hover {
    background-color: #e0e0e0;
  }
</style>


<body>
<script type="module">

  import * as THREE from "{{ url_for('serve_scripts', filename='three.module.js') }}";
  import { OrbitControls } from "{{ url_for('serve_scripts', filename='OrbitControls.js') }}";
  import { STLLoader } from "{{ url_for('serve_scripts', filename='STLLoader.js') }}";
  import { renderTree } from "{{ url_for('serve_scripts', filename='tree.js') }}";
  import { setupSplitter } from "{{ url_for('serve_scripts', filename='splitter.js') }}";

  fetch('/filetree')
    .then(res => res.json())
    .then(data => {
      renderTree(data, document.getElementById('tree'), loadSTL);
    });

const container = document.getElementById('viewer');
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
camera.position.set(0, 50, 100);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(container.clientWidth, container.clientHeight);
container.appendChild(renderer.domElement);

// Controls
const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.dampingFactor = 0.05;
controls.rotateSpeed = 0.5;
controls.zoomSpeed = 0.5;

// Lighting
scene.add(new THREE.AmbientLight(0xF8F8F8));
const directionalLight1 = new THREE.DirectionalLight(0xffffff, 1);
const directionalLight2 = new THREE.DirectionalLight(0xffffff, 1);
directionalLight1.position.set(0, 50, 100).normalize();
directionalLight2.position.set(0, -50, 100).normalize();
scene.add(directionalLight1);
scene.add(directionalLight2);

// Load STL
let mesh = null; 
const loader = new STLLoader();
function loadSTL(relativePath) {
  const stlUrl = `/stls/${relativePath}`;
  loader.load(stlUrl, geometry => {
    // reset the camera so the next object is properly centred on loading
    camera.position.set(0, 100, 100);
    camera.up.set(0, 1, 0);
    camera.lookAt(0, 0, 0);
    controls.target.set(0, 0, 0);

    if (mesh) scene.remove(mesh);
    
    geometry.computeBoundingBox();
    const center = new THREE.Vector3();
    geometry.boundingBox.getCenter(center);
    geometry.translate(-center.x, -center.y, -center.z);

    const material = new THREE.MeshStandardMaterial({ color: 0x6699ff });
    mesh = new THREE.Mesh(geometry, material);
    mesh.rotation.x = -Math.PI / 2; // optional: align model
    scene.add(mesh);
    
    const size = new THREE.Vector3();
    geometry.boundingBox.getSize(size);
    const maxDim = Math.max(size.x, size.y, size.z);
    camera.position.set(0, maxDim/3, maxDim ); 
    
    controls.update();
    renderer.render(scene, camera);
  });
}

// Render loop
function animate() {
  requestAnimationFrame(animate);
  //directionalLight.position.copy(camera.position);
  const direction = new THREE.Vector3();
  camera.getWorldDirection(direction);
  direction.applyAxisAngle(new THREE.Vector3(0, 1, 0), THREE.MathUtils.degToRad(30));
  directionalLight1.position.copy(camera.position.clone().add(direction.multiplyScalar(25)));

  camera.getWorldDirection(direction);
  direction.applyAxisAngle(new THREE.Vector3(0, 1, 0), THREE.MathUtils.degToRad(-30));
  directionalLight2.position.copy(camera.position.clone().add(direction.multiplyScalar(25)));

  renderer.render(scene, camera);
}

animate();

window.addEventListener('resize', resizeViewer);
setupSplitter('splitter', 'tree', 150, 600, resizeViewer);

function resizeViewer() {
  const viewerPane = document.getElementById('viewer');
  renderer.setSize(viewerPane.clientWidth, viewerPane.clientHeight);
  camera.aspect = viewerPane.clientWidth / viewerPane.clientHeight;
  camera.updateProjectionMatrix();
}

</script>

<div id="container">
  <div id="tree"></div>
  <div id="splitter"></div>
  <div id="viewer"></div>
</div>

</body>
</html>
